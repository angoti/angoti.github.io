
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Curso React Native</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="rncursocompletoparte1"
                  title="Curso React Native"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Introdução ao React Native" duration="5">
        <aside class="special"><p>Última atualização: 05/06/2023</p>
</aside>
<p>React Native é um framework que permite criar aplicativos Android e iOS. Você escreve seu código na linguagem de programação JavaScript e JSX. Ele foi desenvolvido pelo Facebook e foi lançado em março de 2015, durante a conferência F8 do Facebook. Foi nesse evento que o Facebook anunciou o React Native como um projeto de código aberto, permitindo que os desenvolvedores o utilizassem para criar aplicativos móveis multiplataforma. Desde então, o React Native tem passado por várias atualizações e continua a ser ativamente desenvolvido e mantido pela comunidade de código aberto e tem ganhado grande popularidade entre os desenvolvedores devido à sua abordagem inovadora e eficiente para o desenvolvimento multiplataforma.</p>
<h2 is-upgraded><strong>Principais características do React Native</strong></h2>
<p>O React Native possui várias características distintivas que o tornam uma escolha popular entre os desenvolvedores. Vamos explorar algumas das principais características e recursos que tornam o React Native uma estrutura de desenvolvimento móvel tão poderosa:</p>
<ul>
<li>Desenvolvimento Multiplataforma: O React Native permite que você desenvolva aplicativos móveis para iOS e Android usando uma base de código comum. Isso significa que você pode compartilhar a lógica de negócios, componentes e funcionalidades entre as duas plataformas, economizando tempo e esforço significativos no desenvolvimento.</li>
<li>Componentes Reutilizáveis: O React Native oferece um conjunto rico de componentes pré-definidos, conhecidos como &#34;componentes básicos&#34; (core components). Esses componentes são construídos com base nos elementos nativos da interface do usuário das plataformas iOS e Android. Além disso, você também pode criar seus próprios componentes personalizados para reutilização em vários aplicativos e projetos.</li>
<li>Abordagem Declarativa: O React Native segue uma abordagem declarativa, em que você descreve como a interface do usuário deve ser renderizada com base no estado atual do aplicativo. Com essa abordagem, você não precisa se preocupar em manipular diretamente as atualizações de interface do usuário. Em vez disso, você define como a interface deve ser exibida em diferentes estados e o React Native se encarrega de atualizá-la de forma eficiente.</li>
<li>Hot Reload: O recurso de &#34;hot reload&#34; do React Native permite que você veja as alterações feitas no código instantaneamente no aplicativo em execução, sem precisar recompilar ou reiniciar o aplicativo. Isso acelera o processo de desenvolvimento, permitindo que você faça alterações e itere rapidamente na interface do usuário, estilos e lógica de negócios.</li>
<li>Acesso a Recursos Nativos: Embora você desenvolva aplicativos usando JavaScript, o React Native oferece acesso a recursos e APIs nativas do dispositivo por meio de módulos JavaScript específicos. Isso significa que você pode acessar facilmente funcionalidades como câmera, GPS, sensores e notificações push, aproveitando as capacidades completas do dispositivo.</li>
<li>Desempenho de Alto Nível: O React Native busca oferecer um desempenho de alto nível, garantindo que os aplicativos sejam executados suavemente e de forma responsiva. Ele utiliza uma arquitetura de thread separada para lidar com as operações de interface do usuário, garantindo uma experiência fluida para os usuários.</li>
<li>Comunidade Ativa: O React Native possui uma comunidade de desenvolvedores ativa e em constante crescimento. Isso significa que há uma abundância de recursos, bibliotecas, exemplos e suporte disponíveis para ajudar os desenvolvedores a resolver problemas, encontrar soluções e acelerar o desenvolvimento de aplicativos.</li>
</ul>
<p>Essas características tornam o React Native uma escolha popular entre os desenvolvedores, permitindo que eles criem aplicativos móveis de alta qualidade, eficientes e nativos para iOS e Android. Com a capacidade de compartilhar código, reutilizar componentes e aproveitar recursos nativos, o React Native oferece uma abordagem produtiva e eficaz para o desenvolvimento móvel.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Ambiente de desenvolvimento" duration="10">
        <p>Vamos utilizar no primeiro semestre do nosso curso uma plataforma chamada <a href="https://snack.expo.dev/" target="_blank"><paper-button class="colored" raised>Snack Expo</paper-button></a> </p>
<p>É uma plataforma para construir e executar aplicativos React Native no navegador. Você pode escrever código React Native e executá-lo diretamente no navegador ou no app Expo Go. Para salvar seus códigos na plataforma Snack você deverá criar uma conta.</p>
<p>A plataforma Expo Go é um ambiente de desenvolvimento para React Native que permite testar e executar aplicativos React Native diretamente em dispositivos móveis iOS e Android. Ele oferece uma maneira rápida e conveniente de visualizar o aplicativo em tempo real durante o processo de desenvolvimento.</p>
<p>Ao usar o Expo Go, os desenvolvedores podem evitar a necessidade de configurar um ambiente de desenvolvimento específico para iOS e Android. Em vez disso, eles podem se concentrar no desenvolvimento do aplicativo em JavaScript usando o Expo CLI ou o Expo Snack.</p>
<h2 is-upgraded><strong>Principais recursos e benefícios da plataforma Expo Go:</strong></h2>
<ul>
<li>Experiência em tempo real: Com o Expo Go, é possível visualizar as alterações no aplicativo em tempo real, à medida que são feitas durante o desenvolvimento. Isso permite uma iteração rápida e uma experiência mais eficiente para ajustar a aparência e o comportamento do aplicativo.</li>
<li>Suporte a hot reload: Assim como o React Native, o Expo Go suporta o recurso de <em>hot reload</em>, permitindo que você veja as alterações feitas no código instantaneamente no aplicativo em execução. Isso facilita a depuração e o ajuste de problemas sem a necessidade de reiniciar o aplicativo.</li>
<li>Acesso a recursos nativos: O Expo Go oferece uma ampla gama de APIs e componentes nativos que podem ser usados em aplicativos React Native. Isso inclui recursos como câmera, GPS, notificações push, armazenamento local e muito mais. Esses recursos nativos podem ser facilmente acessados e utilizados no aplicativo sem a necessidade de configurar e integrar bibliotecas adicionais.</li>
<li>Publicação e compartilhamento fácil: Com o Expo Go, é possível publicar o aplicativo para compartilhamento com outras pessoas de forma rápida e simples. Isso facilita a demonstração do aplicativo para clientes, testadores ou colegas de equipe, permitindo que eles visualizem o aplicativo diretamente em seus dispositivos móveis.</li>
<li>Acesso a comunidade e recursos do Expo: A plataforma Expo Go é suportada pela comunidade Expo, que oferece uma ampla gama de recursos, como documentação, exemplos, bibliotecas adicionais e suporte da comunidade. Isso torna o desenvolvimento com o Expo Go ainda mais fácil e eficiente.</li>
</ul>
<p>Embora o Expo Go seja um ambiente de desenvolvimento muito útil e prático, é importante observar que ele possui algumas limitações em relação ao desenvolvimento nativo tradicional do React Native. Dependendo dos requisitos específicos do aplicativo, pode ser necessário fazer uso do React Native CLI e configurar um ambiente de desenvolvimento nativo completo.</p>
<p>No entanto, para muitos casos de uso, o Expo Go oferece uma solução rápida e eficiente para o desenvolvimento React Native, permitindo que os desenvolvedores testem, iterem e compartilhem aplicativos em tempo real diretamente em dispositivos móveis.</p>
<p class="image-container"><img style="width: 624.00px" src="img\\3f5460a70d1fec9c.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Fundamentos do React Native" duration="20">
        <p>No React Native, os <strong>componentes </strong>são a unidade fundamental para a construção de interfaces de usuário. Um componente é uma parte autônoma e reutilizável do aplicativo que pode ser combinada com outros componentes para criar uma hierarquia de interface do usuário.</p>
<p>Existem dois tipos principais de componentes no React Native:</p>
<ul>
<li><strong>Componentes Funcionais</strong>: Também conhecidos como componentes &#34;stateless&#34; (sem estado), os componentes funcionais são funções JavaScript que recebem um conjunto de propriedades (props) como argumento e retornam elementos React (outra forma de componente).</li>
<li>C<strong>omponentes de Classe</strong>: Também conhecidos como componentes &#34;stateful&#34; (com estado), os componentes de classe são classes JavaScript que estendem a classe React.Component. Eles possuem um estado interno e são capazes de gerenciar a lógica do aplicativo, além de renderizar elementos na interface do usuário.</li>
</ul>
<p>Ao criar componentes no React Native, é importante considerar a reutilização e a modularidade. Componentes bem projetados e reutilizáveis podem acelerar o desenvolvimento, melhorar a manutenção do código e promover uma base de código limpa e organizada.</p>
<p>Neste curso usaremos apenas componentes funcionais para construir nossas aplicações. Em javascript existem duas formas de definir uma função:</p>
<ol type="1" start="1">
<li>Declaração de função</li>
</ol>
<pre>function minhaFuncao(parametro1, parametro2) {
  // corpo da função
 }</pre>
<p>Neste exemplo, usamos a palavra-chave <code>function</code> seguida pelo nome da função (<strong>minhaFuncao</strong>). Em seguida, entre parênteses, você pode listar os parâmetros separados por vírgula, se houver. Dentro das chaves {}, você escreve o corpo da função, onde o código a ser executado quando a função for chamada é definido.</p>
<ol type="1" start="2">
<li>Arrow function</li>
</ol>
<pre>const minhaFuncao = (parametro1, parametro2) =&gt; {
  // corpo da função
};</pre>
<p>As arrow functions (funções de seta) são uma sintaxe mais curta e concisa para definir funções em JavaScript. Neste exemplo, a seta ( =&gt; ) substitui a palavra-chave <em>function</em>, e os parâmetros e o corpo da função são especificados da mesma maneira que nas expressões de função.</p>
<p>Independentemente do método escolhido, você pode chamar a função posteriormente usando seu nome e passando os argumentos necessários, se houver. Por exemplo:</p>
<pre>minhaFuncao(argumento1, argumento2);</pre>
<h2 is-upgraded><strong>Elementos no React Native e JSX</strong></h2>
<p>No React Native, os <strong>elementos</strong> são as unidades básicas que compõem a interface do usuário. Eles representam os componentes em si ou outros elementos. Os elementos são semelhantes aos componentes funcionais e podem ser renderizados na interface do usuário.</p>
<p>JSX (JavaScript XML) é uma extensão de sintaxe do JavaScript que permite a criação de <strong>elementos de interface de usuário</strong> (UI) de forma declarativa. JSX combina XML com JavaScript, permitindo que você escreva componentes de interface de usuário usando uma sintaxe semelhante ao HTML, mas com a capacidade de usar recursos poderosos do JavaScript. A sintaxe JSX torna a criação de elementos e a composição da interface do usuário mais expressiva e legível.</p>
<p>Os elementos JSX são semelhantes aos elementos HTML, mas na verdade são objetos JavaScript. Eles contêm informações sobre o tipo de componente ou elemento que será renderizado, bem como as propriedades (props) associadas a ele. Os elementos também podem conter outros elementos como seus filhos, permitindo a criação de uma hierarquia de elementos/componentes.</p>
<p>Com o JSX, você pode criar hierarquias de elementos UI, definir propriedades e manipular eventos de forma fácil e intuitiva. Ele é usado como uma linguagem de marcação para descrever como os componentes devem ser renderizados.</p>
<p>Aqui está um exemplo de um elemento React Native escrito com a sintaxe JSX:</p>
<pre>&lt;Text style=&#123;&#123; color: &#39;red&#39; }}&gt;Olá mundo&lt;/Text&gt;</pre>
<p>Neste exemplo, o elemento é renderizado como um componente &lt;Text&gt; na interface do usuário, com o estilo definido e o texto &#34;Olá mundo&#34; é exibido na tela.</p>
<p>O JSX é uma parte essencial do desenvolvimento com o React Native, pois simplifica a criação de interfaces de usuário, permitindo que os desenvolvedores escrevam código mais legível e expressivo.</p>
<h2 is-upgraded><strong>Incorporando expressões JavaScript</strong></h2>
<p>Uma das vantagens do JSX é que ele permite a incorporação de expressões JavaScript dentro do código. Isso significa que você pode usar variáveis, funções e até mesmo estruturas de controle para manipular a renderização da interface do usuário. Para escrever código JS dentro de um elemento JSX basta envolver o código JS entre chaves { }.</p>
<p>Por exemplo, vamos supor que temos uma variável <em>isLoggedIn </em>que indica se um usuário está autenticado ou não. Podemos usar essa variável para condicionalmente renderizar diferentes elementos JSX:</p>
<pre>{isLoggedIn ? &lt;WelcomeMessage /&gt; : &lt;LoginButton /&gt;}</pre>
<h2 is-upgraded><strong>Ponto de entrada </strong></h2>
<p>Todas as funcionalidades do aplicativo React Native devem ser incluídas em um único componente React, exportado como padrão (<code>export default</code>) do arquivo de ponto de entrada.</p>
<pre>import * as React from &#39;react&#39;;

const App = () =&gt; (
  // todas as funcionalidades do aplicativo são inseridas aqui
);

export default App;</pre>
<h2 is-upgraded><strong>Pacotes </strong></h2>
<p>Você pode importar diferentes pacotes para obter acesso a diferentes APIs ou funcionalidades nativas.</p>
<pre>import { Camera } from &#39;expo-camera&#39;;
import { Rext, ViewMapView } from &#39;react-native-maps&#39;;</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Componentes básicos" duration="30">
        <p>Temos um conjunto de componentes básicos que usaremos na maioria dos aplicativos:</p>
<table>
<tr><td colspan="1" rowspan="1"><p>REACT NATIVE UI COMPONENTE</p>
</td><td colspan="1" rowspan="1"><p>WEB ANÁLOGO</p>
</td><td colspan="1" rowspan="1"><p>DESCRIÇÃO</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>View</code></strong></p>
</td><td colspan="1" rowspan="1"><p><code>div</code></p>
</td><td colspan="1" rowspan="1"><p>O componente mais fundamental para a construção de uma interface do usuário. </p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>Text</code></strong></p>
</td><td colspan="1" rowspan="1"><p><code>p</code></p>
</td><td colspan="1" rowspan="1"><p>Um componente para exibir texto.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>Image</code></strong></p>
</td><td colspan="1" rowspan="1"><p><code>img</code></p>
</td><td colspan="1" rowspan="1"><p>Um componente para exibir imagens.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>TextInput</code></strong></p>
</td><td colspan="1" rowspan="1"><p><code>input type="text"</code></p>
</td><td colspan="1" rowspan="1"><p>Um componente para inserir texto no aplicativo por meio de um teclado.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>ScrollView</code></strong></p>
</td><td colspan="1" rowspan="1"><p><code>div</code></p>
</td><td colspan="1" rowspan="1"><p>Fornece um contêiner de rolagem que pode hospedar vários componentes e exibições.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><strong><code>Button</code></strong></p>
</td><td colspan="1" rowspan="1"><p>-</p>
</td><td colspan="1" rowspan="1"><p>Um componente de botão básico para lidar com toques. </p>
</td></tr>
</table>
<p>Todos componentes podem ser customizados por meio das propriedades (<strong>props</strong>). Por exemplo, o código abaixo define a quantidade de linhas do texto:</p>
<pre>&lt;Text numberOfLines={1}&gt;Alea jacta est&lt;/Text&gt;</pre>
<p>Para utilizar estes componentes é necessário declarar a sua importação no início do arquivo. Os componentes básicos são importados do pacote <code>'react-native'</code> :</p>
<pre>import { Text } from &#39;react-native&#39;;</pre>
<h2 is-upgraded><strong>Componente &lt;Text&gt; </strong></h2>
<p>O componente &lt;Text&gt; é a única maneira de exibir texto em React Native. Esses componentes podem ser aninhados para herdar e modificar o estilo.</p>
<pre>import { Text, View } from &#39;react-native&#39;;

function App() {
  return (
    &lt;View style=&#123;&#123; flex: 1, margin: 28 }}&gt;
      &lt;Text style=&#123;&#123; color: &#39;blue&#39; }}&gt;
        Texto dentro do componente pai.
        &lt;Text style=&#123;&#123;fontSize:10}}&gt; Texto dentro do componente filho. Herdou a cor do componente pai
        &lt;/Text&gt;
      &lt;/Text&gt;
    &lt;/View&gt;
  );
}
export default App;</pre>
<h2 is-upgraded><strong>Componente &lt;View&gt;  </strong></h2>
<p>O componente &lt;View&gt; é um contêiner &#34;visível&#34; genérico sem qualquer significado semântico ou impacto perceptível no desempenho, melhor traduzido como &lt;div&gt; de web. Utilizado para criar uma UI composta por mais de um componente, quando é necessário envolver os componentes em um container &lt;View&gt;.</p>
<pre>import {Text, View } from &#39;react-native&#39;;

function App() {
  return (
    &lt;View style=&#123;&#123; flex: 1 }}&gt;
      &lt;View style=&#123;&#123; margin: 28, backgroundColor: &#39;red&#39;, color:&#39;#fff&#39; }}&gt;
        &lt;Text style=&#123;&#123; color:&#39;#fff&#39; }}&gt;Texto em branco com fundo vermelho&lt;/Text&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

export default App;</pre>
<h2 is-upgraded><strong>Componente &lt;ScrollView&gt;  </strong></h2>
<p>É um contêiner &#34;visível&#34; genérico com rolagem de tela com impacto no desempenho do aplicativo, tornando-o menos adequado para estilos simples e linhas curtas de texto.</p>
<pre>import { ScrollView, Text, View } from &#39;react-native&#39;;

function App() {
  return (
    &lt;ScrollView&gt;
      &lt;Text style=&#123;&#123; padding: 8 }}&gt;Topo do conteúdo&lt;/Text&gt;
      &lt;View style=&#123;&#123; marginTop: 2000 }} /&gt;
      &lt;Text style=&#123;&#123; padding: 8 }}&gt;Made you look!&lt;/Text&gt;
    &lt;/ScrollView&gt;
  );
}

export default App;</pre>
<h2 is-upgraded><strong>Componente &lt;Image&gt;  </strong></h2>
<p>O componente &lt;Image&gt; é uma maneira otimizada de renderizar imagens de várias fontes, incluindo acesso HTTP remoto, arquivos locais importados com require e strings codificadas em base64. Consulte a <a href="https://reactnative.dev/docs/image#source" target="_blank">documentação</a> para saber mais.</p>
<aside class="warning"><p>ATENÇÃO: para imagens de rede e dados, você precisará especificar manualmente as dimensões de sua imagem!</p>
</aside>
<p>Este exemplo mostra a busca e exibição de uma imagem do armazenamento local, bem como uma da rede e uma imagem codificada em base64&#39;:</p>
<pre>import { View, Image, StyleSheet } from &#39;react-native&#39;;

function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;Image
        source=&#123;&#123;
          uri: &#39;https://assets.betalabs.net/production/flexform/item-images/99d132c62f29d957dae37e0ad4b9a95e.jpg&#39;,
        }}
        style={styles.imagem}
        resizeMode=&#39;contain&#39;
      /&gt;

      &lt;Image
        source={require(&#39;./assets/snack-icon.png&#39;)}
        style={styles.imagem}
        resizeMode=&#39;contain&#39;
      /&gt;

      &lt;Image
        resizeMode=&#39;contain&#39;
        style={styles.imagem}
        source=&#123;&#123;
          uri: &#39;data:image/png;base64,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&#39;,
        }}
      /&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex:1,
    margin: 8,
    marginTop: 30,
    // justifyContent:&#39;center&#39;,
    alignItems:&#39;center&#39;
  },
  imagem: {
    width:&#39;50%&#39;,
    height:&#39;50%&#39;,
    flex:1
  },
});

export default App;</pre>
<h2 is-upgraded><strong>Componentes personalizados</strong></h2>
<p>Componentes personalizados desempenham um papel fundamental no desenvolvimento de aplicativos React Native, permitindo que você crie elementos reutilizáveis e modularize seu código. Nesta seção, vamos explorar como criar e utilizar componentes personalizados, juntamente com exemplos para ilustrar sua aplicação.</p>
<h3 is-upgraded><strong>Criando Componentes Personalizados</strong></h3>
<p>Para criar um componente personalizado, você pode utilizar a funcionalidade de criação de componentes do React Native. Isso envolve a definição de uma função que retorna o JSX desejado. Aqui está um exemplo básico de um componente personalizado de texto:</p>
<pre>import { Text } from &#39;react-native&#39;;

const Texto = () =&gt; {
  return &lt;Text&gt;Alô mundo&lt;/Text&gt;;
};

export default Texto;</pre>
<p>Neste exemplo criamos um componente chamado <code>Texto</code> que renderiza na tela o texto ‘Alô mundo&#39;. Observe que para criar uma componente basta definir uma nova função, neste caso usamos a sintaxe <em>arrow function</em>. Importante notar que o nome da função deve ser escrito com a primeira letra em maiúscula.</p>
<p>Podemos também adicionar a este componente propriedades para, por exemplo, passar para o componente o texto a ser exibido no lugar do texto ‘Alô mundo&#39;:</p>
<pre>import { Text } from &#39;react-native&#39;;

const Texto = ({texto}) =&gt; {
  return &lt;Text&gt;{texto}&lt;/Text&gt;;
};

export default Texto;</pre>
<p>No exemplo acima adicionamos o parâmetro <code>texto</code> à função. Observe que o nome do parâmetro está entre {} na entrada da função e na sua utilização dentro do código JSX (Relembre sobre expressões JavaScript dentro de código JSX na seção <strong>Incorporando expressões JavaScript</strong> do capítulo anterior).</p>
<h3 is-upgraded><strong>Utilizando Componentes Personalizados</strong></h3>
<p>Após criar um componente personalizado, você pode utilizá-lo em qualquer lugar do seu aplicativo React Native. Basta importar o componente e renderizá-lo como faria com qualquer outro componente nativo. Aqui está um exemplo de como usar o componente Texto criado anteriormente:</p>
<pre>import { Text, View } from &#39;react-native&#39;;

export const Texto = ({texto}) =&gt; {
  return &lt;Text&gt;{texto}&lt;/Text&gt;;
};

function App() {
  return (
    &lt;View style=&#123;&#123; margin: 28 }}&gt;
      &lt;Texto texto=&#34;exemplo de criação de componente&#34;/&gt;
    &lt;/View&gt;
  );
}

export default App;</pre>
<p>Ao utilizar componentes personalizados, você pode reutilizá-los em diferentes partes do seu aplicativo, simplificando o código e promovendo a consistência visual. Além disso, você pode estilizar e adicionar funcionalidades adicionais aos componentes personalizados para atender às necessidades específicas do seu projeto.</p>
<p>Componentes personalizados são uma parte essencial do desenvolvimento de aplicativos React Native. Eles permitem que você crie elementos reutilizáveis, modularize seu código e promova a consistência visual em seu aplicativo. Ao criar e utilizar componentes personalizados, você pode simplificar o desenvolvimento, melhorar a manutenibilidade do código e criar interfaces de usuário mais flexíveis.</p>
<h2 is-upgraded><strong>Exercícios</strong></h2>
<aside class="warning"><ol type="1" start="1">
<li>Escreva um app que exibe na tela o texto: ‘Alô mundo&#39;.</li>
<li>Reescreva o exercício 1 agora definindo um novo componente para exibir na tela uma frase qualquer passada ao componente como propriedade.</li>
<li>Crie um componente <code>Titulo</code> que exiba o título ‘Introdução&#39; grande e em negrito na tela</li>
<li>Crie um componente <code>Imagem</code> que exiba a imagem de uma casa na tela.</li>
<li>Crie um componente <code>Paragrafo</code> com uma propriedade chamada <code>texto</code> e exiba este texto justificado na tela.</li>
<li>Crie um componente <code>Card</code> que aceita os parâmetros (props) <code>titulo</code>, <code>texto</code> e <code>imagem</code> e exibe um cartão na tela com as informações fornecidas.</li>
</ol>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Estilização de componentes" duration="30">
        <p>Uma parte importante do desenvolvimento de aplicativos React Native é a estilização de componentes. Nesta seção, exploraremos como aplicar estilos aos componentes e personalizar sua aparência para criar interfaces de usuário atraentes e responsivas.</p>
<h2 is-upgraded><strong>Estilos inline</strong></h2>
<p>No React Native é possível definir estilos embutidos diretamente nos componentes usando a propriedade <code>style</code>. Os estilos embutidos são semelhantes aos estilos em CSS, mas com algumas diferenças sintáticas.</p>
<p>Aqui está um exemplo de como aplicar estilos embutidos a um componente &lt;Text&gt;:</p>
<pre>&lt;Text style=&#123;&#123; fontSize: 16, color: &#39;blue&#39; }}&gt;Hello, World!&lt;/Text&gt;</pre>
<p>Nesse exemplo, definimos um objeto JavaScript (<code>{ fontSize: 16, color: 'blue' })</code> dentro da propriedade <code>style</code>. As propriedades desse objeto representam as regras de estilo, como <code>fontSize</code> e <code>color</code>, seguidas por seus valores correspondentes.</p>
<p>Observe que as propriedades CSS são escritas em <strong>camelCase</strong> (por exemplo, backgroundColor em vez de background-color). Além disso, algumas propriedades podem ter valores diferentes ou limitações em comparação com o CSS padrão, devido às peculiaridades do ambiente de renderização do React Native.</p>
<p>Os estilos embutidos permitem que você defina propriedades de estilo específicas para cada componente individualmente. No entanto, quando você precisa aplicar estilos a vários componentes com propriedades semelhantes, pode ser mais eficiente e organizado o objeto <code>StyleSheet</code>.</p>
<h2 is-upgraded><strong>Componente StyleSheet</strong></h2>
<p>StyleSheet é uma abstração que substitui CSS aceitando regras de estilo CSS usando um objeto JavaScript bidimensional e permite definir estilos separadamente em um objeto JavaScript e aplicá-los a vários componentes. Isso promove a reutilização e a organização do código de estilo. Veja o exemplo abaixo:</p>
<pre> import { Text, View, StyleSheet } from &#39;react-native&#39;;

function App() {
  return (
&lt;View style={styles.container}&gt;
  &lt;Text style={styles.text}&gt;Exemplo de StyleSheet&lt;/Text&gt;
&lt;/View&gt;
  );
}
export default App;

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &#39;gray&#39;,
    alignItems: &#39;center&#39;,
    justifyContent: &#39;center&#39;,
    margin:28
  },
  text: {
    fontSize: 18,
    color: &#39;black&#39;,
  },
});</pre>
<p>Nesse exemplo, usamos o método <code>StyleSheet.create()</code> para criar um objeto de estilo chamado styles. Dentro deste objeto, definimos várias regras de estilo para os componentes.</p>
<p>Usar o objeto <code>StyleSheet</code> é particularmente útil quando você precisa reutilizar estilos em vários componentes ou quando deseja manter a separação de preocupações entre a lógica e a aparência do aplicativo.</p>
<h2 is-upgraded><strong>Estilização avançada</strong></h2>
<p>O React Native oferece recursos avançados de estilização para atender a necessidades mais complexas de interface do usuário. Alguns desses recursos incluem:</p>
<ul>
<li>Uso de flexbox: O flexbox é um modelo de layout poderoso que permite criar layouts flexíveis e responsivos. No React Native, você pode usar propriedades como <code>flexDirection</code>, <code>justifyContent</code> e <code>alignItems</code> para controlar o posicionamento e o dimensionamento dos componentes.</li>
<li>Estilos condicionais: Você pode usar expressões JavaScript dentro de estilos embutidos ou folhas de estilo externas para aplicar estilos condicionalmente com base em determinadas condições. Isso permite que você altere a aparência do componente com base em estados ou dados específicos. Exemplo: <code>style={[styles.paragraph, props.isActive && styles.selected]}</code></li>
<li>Estilização de componentes personalizados: Além de aplicar estilos aos componentes fornecidos pelo React Native, você também pode criar seus próprios componentes personalizados e estilizá-los conforme necessário. Isso permite que você crie uma biblioteca de componentes reutilizáveis e mantenha uma aparência consistente em todo o aplicativo.</li>
</ul>
<h2 is-upgraded><strong>Altura e Largura</strong></h2>
<p>No desenvolvimento de aplicativos React Native, a altura e a largura dos componentes desempenham um papel fundamental na criação de interfaces de usuário responsivas e visualmente agradáveis. Temos três maneiras de trabalhar com a altura e a largura dos componentes: dimensões fixas, dimensões percentuais e dimensões flexíveis.</p>
<h3 is-upgraded><strong>Dimensões fixas</strong></h3>
<p>A maneira geral de definir as dimensões de um componente é atribuindo um valor fixo para a largura (width) e altura (height) ao estilo do componente. Todas as dimensões no React Native não têm unidade e representam pixels independentes de densidade. </p>
<pre>import { View } from &#39;react-native&#39;;

function App() {
  return (
    &lt;View style=&#123;&#123;margin:28}}&gt;
      &lt;View style=&#123;&#123;
        width: 50, height: 50, backgroundColor: &#39;powderblue&#39;
      }} /&gt;
      &lt;View style=&#123;&#123;
        width: 100, height: 100, backgroundColor: &#39;skyblue&#39;
      }} /&gt;
      &lt;View style=&#123;&#123;
        width: 150, height: 150, backgroundColor: &#39;steelblue&#39;
      }} /&gt;
    &lt;/View&gt;
  );
};

export default App;</pre>
<h3 is-upgraded><strong>Dimensões flexíveis</strong></h3>
<p>Use flex no estilo de um componente para que o componente seja expandido e reduzido dinamicamente com base no espaço disponível. Normalmente você usará flex: 1, que diz a um componente para preencher todo o espaço disponível, compartilhado igualmente entre outros componentes com o mesmo pai. Quanto maior o flex dado, maior a proporção de espaço que um componente ocupará em comparação com seus irmãos.</p>
<pre>import { View } from &#39;react-native&#39;;

function App() {
  return (
    &lt;View style=&#123;&#123; margin: 28, flex: 1 }}&gt;
      &lt;View style=&#123;&#123; flex: 1 }}&gt;
        &lt;View style=&#123;&#123; flex: 1, backgroundColor: &#39;powderblue&#39; }} /&gt;
        &lt;View style=&#123;&#123; flex: 2, backgroundColor: &#39;skyblue&#39; }} /&gt;
        &lt;View style=&#123;&#123; flex: 3, backgroundColor: &#39;steelblue&#39; }} /&gt;
      &lt;/View&gt;
    &lt;/View&gt;
  );
}

export default App;</pre>
<h3 is-upgraded><strong>Dimensões Percentuais</strong></h3>
<p>Se você deseja preencher uma determinada parte da tela, mas não deseja usar o flex layout, pode usar valores percentuais no estilo do componente. Semelhante às dimensões flexíveis, as dimensões percentuais requerem um pai com um tamanho definido.</p>
<pre>import { View } from &#39;react-native&#39;;

function App() {
  return (
    &lt;View style=&#123;&#123; height: &#39;100%&#39;,margin:28 }}&gt;
      &lt;View style=&#123;&#123;
        height: &#39;15%&#39;, backgroundColor: &#39;powderblue&#39;
      }} /&gt;
      &lt;View style=&#123;&#123;
        width: &#39;66%&#39;, height: &#39;35%&#39;, backgroundColor: &#39;skyblue&#39;
      }} /&gt;
      &lt;View style=&#123;&#123;
        width: &#39;33%&#39;, height: &#39;50%&#39;, backgroundColor: &#39;steelblue&#39;
      }} /&gt;
    &lt;/View&gt;
  );
}

export default App;</pre>
<h2 is-upgraded><strong>Exercícios</strong></h2>
<p>Para o exercício 2 use o código  a seguir como modelo.</p>
<pre>import { View, StyleSheet } from &#39;react-native&#39;;
import { SafeAreaView } from &#39;react-native-safe-area-context&#39;;

function App() {
  return (
    &lt;SafeAreaView style={styles.container}&gt;
      &lt;View style={[styles.quadrado, styles.cor1]} /&gt;
      &lt;View style={[styles.quadrado, styles.cor2]} /&gt;
      &lt;View style={[styles.quadrado, styles.cor3]} /&gt;
      &lt;View style={[styles.quadrado, styles.cor4]} /&gt;
    &lt;/SafeAreaView&gt;
  );
}

const styles = StyleSheet.create({
  quadrado: {
    width: 100,
    height: 100,
  },
  cor1: {
    backgroundColor: &#39;#50E3C2&#39;,
  },
  cor2: {
    backgroundColor: &#39;#4A90E2&#39;,
  },
  cor3: {
    backgroundColor: &#39;#9013FE&#39;,
  },
  cor4: {
    backgroundColor: &#39;#F5A623&#39;,
  },
  container: {
    margin: 8,
  },
});

export default App;</pre>
<p>Este código gera a tela:</p>
<p class="image-container"><img style="width: 285.00px" src="img\\a65185f96f765000.png"></p>
<aside class="warning"><ol type="1" start="1">
<li>Resolver os 24 exercícios sobre <a href="https://flexboxfroggy.com/" target="_blank">Flexbox </a></li>
<li>Para os próximos exercícios use Flexbox e o exemplo abaixo para exibir quadrados na tela:</li>
</ol>
<table>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 215.18px" src="img\\c856f20938b8a811.png"></p>
<p>2.1</p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 197.32px" src="img\\8dfe582f6a78da3e.png"></p>
<p>2.2</p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 194.09px" src="img\\1a3460506817d4d0.png"></p>
<p>2.3</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 194.00px" src="img\\409ca8bee5740b99.png"></p>
<p>2.4</p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 200.50px" src="img\\f0a9fc5e5cc2d7a.png"></p>
<p>2.5</p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img style="width: 200.50px" src="img\\c252fd3471106f95.png"></p>
<p>2.6</p>
</td></tr>
</table>
<ol type="1" start="3">
<li>Construir um app que exibe uma tela conforme a imagem abaixo.</li>
</ol>
<p class="image-container"><img style="width: 252.00px" src="img\\6ffc3e03cfa74eeb.png"></p>
<p>- as imagens das placas estão nos links abaixo:</p>
<ul>
<li><a href="https://drive.google.com/file/d/1oBWOvPzrmciTgwtmSCjXtj7VTzHlbmwL/view?usp=drive_web&authuser=0" target="_blank">placa1</a></li>
<li><a href="https://drive.google.com/file/d/1QCe1_ifHq8FVf5al8H7ZHMWFU-3qmILy/view?usp=drive_web&authuser=0" target="_blank">placa2</a></li>
<li><a href="https://drive.google.com/file/d/1eCcNPxB4aXldWePXGMkmXpjZ1Se77zTI/view?usp=drive_web&authuser=0" target="_blank">placa3</a></li>
<li><a href="https://drive.google.com/file/d/1elINhin-0FaBpXrYucOckKQRYWWQHub7/view?usp=drive_web&authuser=0" target="_blank">placa4</a></li>
</ul>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Entrada de dados" duration="30">
        <p>Neste capítulo, vamos explorar como lidar com a entrada de dados em um aplicativo React Native usando os componentes <code>TextInput</code>, <code>Button</code> e <code>Pressable</code>. A entrada de dados é uma parte essencial de muitos aplicativos, permitindo que os usuários interajam e forneçam informações ao aplicativo.</p>
<h2 is-upgraded><strong>Componentes &lt;TextInput&gt; e &lt;Button&gt;</strong></h2>
<p>O componente <code>TextInput</code> é usado para receber entrada de texto do usuário. Ele permite que os usuários digitem texto em um campo de entrada de texto e interajam com ele. Vamos dar uma olhada no código visto anteriormente e trocar o componente <code>Button</code> pelo componente <code>Pressable</code>:</p>
<pre>import { useState } from &#39;react&#39;;
import { View, TextInput, Button, Alert } from &#39;react-native&#39;;

function App() {
  const [texto, setTexto] = useState(&#39;&#39;);
  
  const handleButtonPress = () =&gt; {
    Alert.alert(&#39;Texto digitado:&#39;, texto);
  };
  
  return (
    &lt;View style=&#123;&#123; marginTop: 40, margin: 8, flex: 1 }}&gt;
      &lt;TextInput
        style=&#123;&#123;
          fontSize: 20,
          height: 40,
          borderColor: &#39;gray&#39;,
          borderWidth: 1,
          padding: 8,
          marginBottom:8
        }}
        onChangeText={setTexto}
        value={texto}
      /&gt;
      &lt;Button title=&#34;Enviar&#34; onPress={handleButtonPress} /&gt;
    &lt;/View&gt;
  );
}

export default App;</pre>
<p>Neste exemplo, importamos o &lt;TextInput&gt; da biblioteca react-native e usamos o componente dentro do componente &lt;View&gt;. O &lt;TextInput&gt; tem duas propriedades importantes: onChangeText e value.</p>
<p>A propriedade onChangeText recebe uma função que será chamada sempre que o texto no &lt;TextInput&gt; for alterado. Neste exemplo, usamos a função <code>setTexto</code>, fornecida pelo hook useState(), que atualiza o estado da variável <code>texto</code> a cada momento que o usuário digita dentro do campo de entrada &lt;TextInput&gt;.</p>
<p>A propriedade value define o valor do &lt;TextInput&gt;. Neste caso, estamos definindo o valor como <code>texto</code>, que é variável de estado que controla o valor do campo de entrada do componente &lt;TextInput&gt;.</p>
<p>Em seguida, temos o componente &lt;Button&gt; que renderiza um botão &#34;Enviar&#34;. Quando o botão é pressionado, a função <code>handleButtonPress</code> é chamada. Essa função exibe um alerta com o texto digitado pelo usuário usando Alert.alert. Este componente não permite estilização, ou seja, mudar cor ou texto ou qualquer outra característica. É usado principalmente para prototipação rápida.</p>
<aside class="special"><p>Os hooks são uma adição poderosa ao React que permitem que os componentes funcionais tenham recursos de estado e ciclo de vida. Eles foram introduzidos na versão 16.8 do React e fornecem uma forma mais concisa e intuitiva de escrever componentes complexos.</p>
<p>Os hooks são funções especiais que podem ser usadas em componentes funcionais do React. Eles permitem que você adicione recursos como estado, efeitos colaterais e outros comportamentos ao seu componente sem a necessidade de converter o componente para uma classe.</p>
<p>Existem alguns hooks principais no React, sendo os mais comuns:</p>
<p><strong><code>useState</code></strong>: permite adicionar estado a um componente funcional. Ele retorna um par de valores: o estado atual e uma função para atualizar esse estado. Por exemplo, const [count, setCount] = useState(0) cria uma variável count que é inicializada com o valor 0 e uma função setCount que pode ser usada para atualizar o valor de count.</p>
<p><strong><code>useEffect</code></strong>: permite executar efeitos colaterais em um componente funcional. Ele é executado após cada renderização e pode ser usado para buscar dados, manipular o DOM, registrar eventos e muito mais. Por exemplo, useEffect(() =&gt; { console.log(&#39;Componente montado&#39;) }, []) executa a função de retorno quando o componente é montado, pois passamos um array vazio como segundo argumento para indicar que não há dependências.</p>
<p>Existem também outros hooks personalizados que você pode criar ou usar a partir de bibliotecas de terceiros. Esses hooks permitem encapsular lógicas específicas do componente para reutilização em diferentes partes do aplicativo.</p>
<p>Em resumo, os hooks fornecem uma maneira eficiente e declarativa de adicionar recursos a componentes funcionais do React. Eles ajudam a manter o código mais legível, modular e fácil de testar. Com a combinação correta de hooks, você pode criar componentes complexos com menos código e maior flexibilidade.</p>
</aside>
<p>A necessidade de usar um hook, como o useState, para controlar o estado de uma variável em um componente funcional se deve a como o React gerencia a renderização e atualização desses componentes.</p>
<p>Quando um componente funcional é renderizado, ele é executado novamente sempre que há uma mudança em qualquer uma de suas dependências, como props ou estado. Isso significa que uma nova instância da função do componente é criada e todos os cálculos dentro dela são refeitos.</p>
<p>Se atribuíssemos um valor diretamente a uma variável no corpo do componente, toda vez que o componente fosse renderizado novamente, essa atribuição seria refeita e a variável seria reinicializada com seu valor original. Dessa forma, perderíamos a capacidade de manter o estado entre as renderizações e todas as alterações feitas anteriormente seriam perdidas.</p>
<p>Além disso, ao usar o useState, o React também otimiza o desempenho, permitindo que ele identifique apenas as partes do componente que realmente precisam ser atualizadas na tela, em vez de renderizar todo o componente novamente.</p>
<p>Em resumo, ao utilizar um hook como o useState, estamos aproveitando a capacidade do React de gerenciar o estado e garantir que as alterações sejam preservadas entre as renderizações do componente. Isso nos permite criar componentes mais dinâmicos e interativos, mantendo um bom desempenho em nossos aplicativos React.</p>
<h2 is-upgraded><strong>Componente &lt;Pressable&gt;</strong></h2>
<p>O componente <code>Pressable</code> é usado para detectar toques ou pressões do usuário em uma área específica. Podemos aproveitar esse componente para criar interações com a entrada de dados. Este componente permite estilização, ao contrário do componente <code>Button</code>. Vamos ver um exemplo de uso do <code>Pressable</code>:</p>
<pre>import { useState } from &#39;react&#39;;
import { Pressable, Text, View, TextInput, Button, Alert } from &#39;react-native&#39;;

function App() {
  const [texto, setTexto] = useState(&#39;&#39;);

  const handleButtonPress = () =&gt; {
    Alert.alert(&#39;Texto digitado:&#39;, texto);
  };

  return (
    &lt;View style=&#123;&#123; marginTop: 40, margin: 8, flex: 1 }}&gt;
      &lt;TextInput
        style=&#123;&#123;
          fontSize: 20,
          height: 40,
          borderColor: &#39;gray&#39;,
          borderWidth: 1,
          padding: 8,
          marginBottom: 8,
        }}
        onChangeText={setTexto}
        value={texto}
      /&gt;
      &lt;Pressable onPress={handleButtonPress}&gt;
        &lt;Text
          style=&#123;&#123;
            padding: 8,
            width: &#39;100%&#39;,
            color: &#39;blue&#39;,
            fontSize: 20,
            textAlign: &#39;center&#39;,
            backgroundColor: &#39;#8b5&#39;,
            borderRadius:12
          }}&gt;
          Enviar
        &lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

export default App;</pre>
<p>Neste exemplo, além do componente <code>TextInput</code>, adicionamos o <code>Pressable</code> em vez do <code>Button</code>. O <code>Pressable</code> envolve um texto &#34;Enviar&#34; e, quando é pressionado, a função <strong>handleButtonPress </strong>é chamada. Observe a estilização do componente <code>Pressable</code>, que não é possível no componente <code>Button</code>.</p>
<h2 is-upgraded><strong>Exercícios</strong></h2>
<aside class="warning"><ol type="1" start="1">
<li>Crie um aplicativo React Native com um &lt;TextInput&gt; e um &lt;Button&gt;. Ao pressionar o botão, exiba um alerta com o texto digitado pelo usuário.</li>
<li>Modifique o aplicativo anterior para adicionar validação, onde o usuário só pode enviar o texto se tiver mais de 5 caracteres.</li>
<li>Adicione um novo componente &lt;Pressable&gt; ao aplicativo anterior, ao lado do &lt;Button&gt;, para exibir o texto digitado quando for pressionado.</li>
<li>Crie um novo aplicativo onde o usuário possa digitar um nome em um &lt;TextInput&gt; e, ao pressionar um &lt;Button&gt;, o nome digitado seja exibido em um &lt;Text&gt; abaixo do campo de entrada.</li>
</ol>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Projeto Jogo da forca" duration="10">
        <h2 is-upgraded><strong>Introdução</strong></h2>
<p>Ao fim deste projeto teremos o famoso jogo da forca completamente desenvolvido. O projeto será realizado em quatro etapas, e vamos aprender conceitos importantes para a programação de aplicativos em React Native.</p>
<h2 is-upgraded><strong>O que você vai aprender</strong></h2>
<ul>
<li>Versão 1: Lógica para manipular exibição de imagens diferentes.</li>
<li>Versão 2: Renderização condicional. Implementação da lógica do jogo para adivinhar uma letra usando &lt;TextInput&gt;.</li>
<li>Versão 3: Implementação da lógica do jogo para adivinhar uma palavra sorteada usando &lt;TextInput&gt;.</li>
<li>Versão 4: Componentização e exibição de teclado.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Projeto Jogo da forca - V1" duration="40">
        <p><a href="https://snack.expo.dev/@professor-angoti/forca-v1" target="_blank">Link Snack</a></p>
<pre>import { View, Pressable, Image, StyleSheet, Text } from &#39;react-native&#39;;
import { useState } from &#39;react&#39;;

function App() {
  const forca1 = require(&#39;./assets/forca.png&#39;);
  const forca2 = require(&#39;./assets/cabeca.png&#39;);
  const forca3 = require(&#39;./assets/cabecacorpo.png&#39;);
  const forca4 = require(&#39;./assets/cabecacorpoumbraco.png&#39;);
  const forca5 = require(&#39;./assets/cabecacorpodoisbracos.png&#39;);
  const forca6 = require(&#39;./assets/cabecacorpodoisbracosumaperna.png&#39;);
  const forca7 = require(&#39;./assets/cabecacorpodoisbracosduaspernas.png&#39;);

  const lista = [forca1, forca2, forca3, forca4, forca5, forca6, forca7];

  const [situacao, setSituacao] = useState(0);

  function onPress() {
    if (situacao == 6) {
      setSituacao(0);
    } else {
      setSituacao(situacao + 1);
    }
  }

  return (
    &lt;View style={styles.container}&gt;
      &lt;Image style={styles.imagem} source={lista[situacao]} /&gt;
      &lt;Pressable style={styles.botao} onPress={onPress}&gt;
        &lt;Text style={styles.texto}&gt;Tentativa&lt;/Text&gt;
      &lt;/Pressable&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: &#39;center&#39;,
    justifyContent: &#39;center&#39;,
  },
  imagem: {
    width: &#39;50%&#39;,
    height: &#39;50%&#39;,
    borderWidth: 1,
    marginBottom: 20,
  },
  botao: {
    paddingVertical: 12,
    paddingHorizontal: 32,
    borderRadius: 4,
    elevation: 3,
    backgroundColor: &#39;black&#39;,
  },
  texto: {
    fontSize: 16,
    lineHeight: 21,
    fontWeight: &#39;bold&#39;,
    letterSpacing: 0.25,
    color: &#39;white&#39;,
  },
});

export default App;</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Projeto Jogo da forca - V2" duration="40">
        <p><a href="https://snack.expo.dev/@professor-angoti/forca-v2" target="_blank">Link Snack</a></p>
<pre>import {
  View,
  Pressable,
  Image,
  StyleSheet,
  Text,
  TextInput,
} from &#39;react-native&#39;;
import { useState } from &#39;react&#39;;

function App() {
  const forca1 = require(&#39;./assets/forca.png&#39;);
  const forca2 = require(&#39;./assets/cabeca.png&#39;);
  const forca3 = require(&#39;./assets/cabecacorpo.png&#39;);
  const forca4 = require(&#39;./assets/cabecacorpoumbraco.png&#39;);
  const forca5 = require(&#39;./assets/cabecacorpodoisbracos.png&#39;);
  const forca6 = require(&#39;./assets/cabecacorpodoisbracosumaperna.png&#39;);
  const forca7 = require(&#39;./assets/cabecacorpodoisbracosduaspernas.png&#39;);

  const lista = [forca1, forca2, forca3, forca4, forca5, forca6, forca7];
  const letra = &#39;S&#39;;

  const [situacao, setSituacao] = useState(0);
  const [palpite, onChangePalpite] = useState(&#39;&#39;);
  const [mensagem, setMensagem] = useState(&#39;&#39;);
  const [fimDeJogo, setFimDeJogo] = useState(false);

  function validarPalpite() {
    console.log(&#39;---------&gt; &#39;, palpite.toUpperCase());
    if (letra.toUpperCase() === palpite.toUpperCase()) {
      setMensagem(&#39;acertou&#39;);
      setFimDeJogo(true);
      setSituacao(0);
    } else if (situacao &lt; 6) {
      setSituacao(situacao + 1);
      onChangePalpite(&#39;&#39;);
    } else {
      setFimDeJogo(true);
      setMensagem(&#39;perdeu&#39;);
    }
  }

  function novo() {
    setMensagem(&#39;&#39;);
    setSituacao(0);
    setFimDeJogo(false);
    onChangePalpite(&#39;&#39;);
  }

  return (
    &lt;View style={styles.container}&gt;
      &lt;Text style={styles.mensagem}&gt;{mensagem}&lt;/Text&gt;
      &lt;Image style={styles.imagem} source={lista[situacao]} /&gt;
      &lt;TextInput
        style={styles.input}
        maxLength={1}
        onChangeText={onChangePalpite}
        value={palpite}
        autoCapitalize=&#34;characters&#34;
      /&gt;
      {!fimDeJogo &amp;&amp; (
        &lt;Pressable style={styles.botao} onPress={validarPalpite}&gt;
          &lt;Text style={styles.texto}&gt;Tentativa&lt;/Text&gt;
        &lt;/Pressable&gt;
      )}
      {fimDeJogo &amp;&amp; (
        &lt;Pressable style={styles.botao} onPress={novo}&gt;
          &lt;Text style={styles.texto}&gt;Novo jogo&lt;/Text&gt;
        &lt;/Pressable&gt;
      )}
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: &#39;center&#39;,
    justifyContent: &#39;center&#39;,
  },
  imagem: {
    width: &#39;50%&#39;,
    height: &#39;50%&#39;,
    // borderWidth: 1,
    resizeMode: &#39;contain&#39;,
  },
  botao: {
    paddingVertical: 12,
    paddingHorizontal: 32,
    borderRadius: 4,
    elevation: 3,
    backgroundColor: &#39;black&#39;,
    margin: 12,
    width: &#39;50%&#39;,
  },
  texto: {
    fontSize: 16,
    lineHeight: 21,
    fontWeight: &#39;bold&#39;,
    letterSpacing: 0.25,
    color: &#39;white&#39;,
    alignSelf: &#39;center&#39;,
  },
  input: {
    height: 40,
    width: 40,
    margin: 12,
    borderWidth: 1,
    textAlign: &#39;center&#39;,
    fontSize: 20,
  },
  mensagem: {
    fontSize: 50,
    margin: 12,
    color: &#39;red&#39;,
  },
});

export default App;</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Flatlist" duration="30">
        <h2 is-upgraded><strong>Introdução ao componente FlatList</strong></h2>
<p>O FlatList é um componente do React Native que permite exibir listas de elementos de forma eficiente, independentemente do tamanho da lista. Ele é especialmente útil para listas longas e dinâmicas que podem ser renderizadas sob demanda, melhorando o desempenho e a experiência do usuário. Veja exemplo:</p>
<p class="image-container"><img style="width: 426.00px" src="img\\e4cd5b8913a9f26b.gif"></p>
<aside class="special"><p>Referência: <a href="https://reactnative.dev/docs/flatlist" target="_blank">FlatList · React Native</a></p>
</aside>
<h2 is-upgraded>Como usar o componente FlatList</h2>
<p>Para usar o componente FlatList, você precisa primeiro importá-lo do pacote react-native. Em seguida, você pode renderizar uma lista de elementos com o FlatList passando as seguintes propriedades:</p>
<p><code>data</code>: um array de objetos que serão exibidos na lista.</p>
<p><code>renderItem</code>: uma função que recebe cada item do array e retorna um componente React que será exibido na lista.</p>
<p>A lista deve ser composta por objetos e cada objeto deve ter uma propriedade chamada <code>id</code> com valor único para cada objeto.</p>
<p>Aqui está um exemplo básico de como usar o FlatList:</p>
<pre>import { View, FlatList, StyleSheet, Text } from &#39;react-native&#39;;

const DATA = [
  { id: &#39;1&#39;, title: &#39;Item 1&#39; },
  { id: &#39;2&#39;, title: &#39;Item 2&#39; },
  { id: &#39;3&#39;, title: &#39;Item 3&#39; },
  { id: &#39;4&#39;, title: &#39;Item 4&#39; },
  { id: &#39;5&#39;, title: &#39;Item 5&#39; },
  { id: &#39;6&#39;, title: &#39;Item 6&#39; },
  { id: &#39;7&#39;, title: &#39;Item 7&#39; },
  { id: &#39;8&#39;, title: &#39;Item 8&#39; },
  { id: &#39;9&#39;, title: &#39;Item 9&#39; },
  { id: &#39;10&#39;, title: &#39;Item 10&#39; },
  { id: &#39;11&#39;, title: &#39;Item 11&#39; },
  { id: &#39;12&#39;, title: &#39;Item 12&#39; },
  { id: &#39;13&#39;, title: &#39;Item 13&#39; },
  { id: &#39;14&#39;, title: &#39;Item 14&#39; },
  { id: &#39;15&#39;, title: &#39;Item 15&#39; },
  { id: &#39;16&#39;, title: &#39;Item 16&#39; },
  { id: &#39;17&#39;, title: &#39;Item 17&#39; },
  { id: &#39;18&#39;, title: &#39;Item 18&#39; },
  { id: &#39;19&#39;, title: &#39;Item 19&#39; },
  { id: &#39;20&#39;, title: &#39;Item 20&#39; },
];

const App = () =&gt; {
  const renderizarItem = ({ item }) =&gt; (
    &lt;View style={styles.item}&gt;
      &lt;Text style={styles.title}&gt;{item.title}&lt;/Text&gt;
    &lt;/View&gt;
  );

  return (
    &lt;View style={styles.container}&gt;
      &lt;FlatList data={DATA} renderItem={renderizarItem} /&gt;
    &lt;/View&gt;
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    margin: 10,
    marginTop: 50,
  },
  item: {
    borderWidth: 1,
    borderColor: &#39;red&#39;,
    padding: 10,
  },
  title: {
    fontSize: 30,
  },
});

export default App;</pre>
<p>Neste exemplo, estamos renderizando uma lista simples de vinte itens. Cada item é representado por um objeto que contém uma chave <code>id</code> e um título <code>title</code>. O componente FlatList recebe o array de objetos DATA, que é renderizado com a função <code>renderizarItem</code>, que retorna um componente <code>View</code> com o título do item.</p>
<aside class="warning"><p>Exercício: Altere o código para mostrar também a chave id de cada item da lista</p>
</aside>
<h2 is-upgraded><strong>Propriedades do componente FlatList</strong></h2>
<p>O FlatList possui várias propriedades que permitem personalizar sua aparência e comportamento. Algumas das propriedades mais comuns incluem:</p>
<p><code>ItemSeparatorComponent</code>: um componente React que é renderizado entre cada item da lista. Isso permite adicionar um separador visual entre os itens.</p>
<p><code>ListHeaderComponent</code>: um componente React que é renderizado no topo da lista. Isso permite adicionar um cabeçalho à lista.</p>
<p><code>ListFooterComponent</code>: um componente React que é renderizado no final da lista. Isso permite adicionar um rodapé à lista.</p>
<p>onEndReached: uma função que é chamada quando o usuário chega ao final da lista. Isso é útil para carregar mais itens dinamicamente à medida que o usuário rola a lista.</p>
<p><code>onRefresh</code>: é uma função que é chamada quando o usuário realiza uma ação de &#34;puxar para atualizar&#34; na lista. Isso é útil para atualizar os dados da lista com informações mais recentes.</p>
<p>Concluindo, o componente FlatList é uma ferramenta poderosa para renderizar listas de elementos em um aplicativo React Native. Com ele, é possível exibir listas dinâmicas e longas de forma eficiente, melhorando a experiência do usuário. É importante entender as propriedades do FlatList e como usá-las para personalizar a aparência e o comportamento da lista. Com o conhecimento adequado, os alunos de ensino técnico podem criar aplicativos móveis sofisticados e funcionais usando o FlatList.</p>
<h2 is-upgraded><strong>Exemplos de uso da o componente FlatList</strong></h2>
<p>O FlatList é um dos componentes mais versáteis do React Native e pode ser usado de várias maneiras para renderizar listas de dados. Aqui estão alguns exemplos diversificados de como utilizar o FlatList:</p>
<h3 is-upgraded><strong>Exemplo 1: Listagem de Produtos</strong></h3>
<p>Suponha que você tenha uma lista de produtos e queira exibi-los em uma tela. Você pode utilizar o FlatList para renderizar esses produtos da seguinte maneira:</p>
<pre>import { FlatList, View, Text, Image, StyleSheet } from &#39;react-native&#39;;

const products = [
  {
    id: 1,
    name: &#39;Product 1&#39;,
    price: 9.99,
    image: { uri: &#39;https://picsum.photos/id/1024/400/400&#39; },
  },
  {
    id: 2,
    name: &#39;Product 2&#39;,
    price: 14.99,
    image: { uri: &#39;https://picsum.photos/id/1026/400/400&#39; },
  },
  {
    id: 3,
    name: &#39;Product 3&#39;,
    price: 19.99,
    image: { uri: &#39;https://picsum.photos/id/1043/400/400&#39; },
  },
  {
    id: 4,
    name: &#39;Product 4&#39;,
    price: 24.99,
    image: { uri: &#39;https://picsum.photos/id/1062/400/400&#39; },
  },
  {
    id: 5,
    name: &#39;Product 5&#39;,
    price: 29.99,
    image: { uri: &#39;https://picsum.photos/id/1074/400/400&#39; },
  },
];

const renderItem = ({ item }) =&gt; (
  &lt;View style={styles.item}&gt;
    &lt;Image source={item.image} style={styles.image} /&gt;
    &lt;Text style={styles.title}&gt;{item.name}&lt;/Text&gt;
    &lt;Text style={styles.price}&gt;${item.price}&lt;/Text&gt;
  &lt;/View&gt;
);

const App = () =&gt; (
  &lt;FlatList
    data={products}
    renderItem={renderItem}
    keyExtractor={(item) =&gt; item.id.toString()}
    style={styles.container}
  /&gt;
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    marginTop:40
  },
  item: {
    backgroundColor: &#39;#f9c2ff&#39;,
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
  },
  title: {
    fontSize: 32,
  },
  price: {
    fontSize: 24,
  },
  image: {
    width: &#39;100%&#39;,
    height: 200,
  },
});

export default App;</pre>
<h3 is-upgraded><strong>Exemplo 2: Listagem de Imagens com Paginação</strong></h3>
<p>Suponha que você queira exibir uma lista de imagens que estão armazenadas em um servidor e quer exibir apenas algumas imagens por vez, permitindo ao usuário navegar entre as páginas para ver mais imagens. Você pode utilizar o FlatList com a propriedade <code>pagingEnabled</code> para exibir a lista de imagens com paginação. Para paginar faça o gesto de arrastar para cima:</p>
<pre>import { useState, useEffect } from &#39;react&#39;;
import { FlatList, Image, View, StyleSheet } from &#39;react-native&#39;;

const App = () =&gt; {
  const [images, setImages] = useState([]);
  const [page, setPage] = useState(1);

  useEffect(() =&gt; {
    fetch(`https://picsum.photos/v2/list?page=${page}&amp;limit=10`)
      .then((response) =&gt; response.json())
      .then((data) =&gt; setImages(data))
      .catch((error) =&gt; console.error(error));
  }, [page]);

  const renderItem = ({ item }) =&gt; (
    &lt;View style={styles.item}&gt;
      &lt;Image source=&#123;&#123; uri: item.download_url }} style={styles.image} /&gt;
    &lt;/View&gt;
  );

  const handleEndReached = () =&gt; {
    setPage(page + 1);
  };

  return (
    &lt;FlatList
      data={images}
      renderItem={renderItem}
      keyExtractor={(item) =&gt; item.id.toString()}
      style={styles.container}
      contentContainerStyle={styles.contentContainer}
      numColumns={2}
      // habilita a paginação
      pagingEnabled={true}
      // define a função &#39;onEndReached&#39; para carregar mais imagens quando o usuário chegar ao final da lista
      onEndReached={handleEndReached}
      // define a quantidade de pixels que o usuário precisa rolar a lista para que a função &#39;onEndReached&#39; seja disparada
      onEndReachedThreshold={0.1}
    /&gt;
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &#39;#f1f1f1&#39;,
  },
  contentContainer: {
    paddingVertical: 20,
    paddingHorizontal: 10,
  },
  item: {
    flex: 1,
    marginHorizontal: 5,
    marginVertical: 10,
    aspectRatio: 1,
  },
  image: {
    flex: 1,
    borderRadius: 5,
  },
});

export default App;</pre>
<h3 is-upgraded><strong>Exemplo 3: Listagem de Notícias</strong></h3>
<p>Suponha que você tenha uma lista de notícias e queira exibi-las em uma tela. Você pode utilizar o FlatList para renderizar essas notícias da seguinte maneira:</p>
<pre>import { FlatList, View, Text, Image, StyleSheet } from &#39;react-native&#39;;

const news = [
  {
    id: 1,
    title:
      &#39;Casos de covid no mundo ultrapassam 400 milhões com domínio global da ômicron&#39;,
    summary:
      &#39;A Organização Mundial da Saúde (OMS) alertou nesta segunda-feira que o número de casos de covid-19 no mundo ultrapassou a marca de 400 milhões, com o domínio global da variante ômicron do vírus.&#39;,
  },

  {
    id: 2,
    title:
      &#39;França decreta novo confinamento para conter segunda onda da Covid-19&#39;,
    summary:
      &#39;A França decretou novo confinamento a partir desta quinta-feira (10) para conter a segunda onda da Covid-19 que, segundo o primeiro-ministro francês, Jean Castex, é mais forte que as anteriores.&#39;,
  },

  {
    id: 3,
    title: &#39;Nasa acha componente do plástico em lua de Saturno&#39;,
    summary:
      &#39;A sonda espacial Cassini encontrou fragmentos de plástico em Titã, uma das luas de Saturno, mostrando que a poluição causada pelo homem pode chegar a lugares muito distantes.&#39;,
  },

  {
    id: 4,
    title: &#39;Nasa pousa sonda em asteroide e coleta amostras da rocha&#39;,
    summary:
      &#39;A sonda OSIRIS-REx da Nasa pousou no asteroide Bennu na noite desta terça-feira (20) e coletou amostras da rocha espacial. Esta é a primeira vez que uma missão da Nasa tenta coletar amostras de um asteroide.&#39;,
  },
];

const renderItem = ({ item }) =&gt; (
  &lt;View style={styles.item}&gt;
    &lt;Text style={styles.title}&gt;{item.title}&lt;/Text&gt;
    &lt;Text style={styles.summary}&gt;{item.summary}&lt;/Text&gt;
  &lt;/View&gt;
);

const App = () =&gt; (
  &lt;FlatList
    data={news}
    renderItem={renderItem}
    keyExtractor={(item) =&gt; item.id.toString()}
    style={styles.container}
  /&gt;
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    marginTop:30
  },
  item: {
    backgroundColor: &#39;#fff&#39;,
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
    borderRadius: 10,
    shadowColor: &#39;#000&#39;,
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  title: {
    fontSize: 24,
    fontWeight: &#39;bold&#39;,
    marginBottom: 10,
  },
  summary: {
    fontSize: 18,
  },
  image: {
    width: &#39;100%&#39;,
    height: 200,
    borderRadius: 10,
    marginBottom: 10,
  },
});

export default App;</pre>
<h2 is-upgraded><strong>Exercícios com solução</strong></h2>
<pre><code>const data = [
  { id: &#39;1&#39;, title: &#39;Item 1&#39; },
  { id: &#39;2&#39;, title: &#39;Item 2&#39; },
  { id: &#39;3&#39;, title: &#39;Item 3&#39; },
];</code></pre>
<p>Listagem 1</p>
<pre><code>import { View, FlatList, Text } from &#39;react-native&#39;;
function ListaItens() {
  const data = [
    { id: &#39;1&#39;, title: &#39;Item 1&#39; },
    { id: &#39;2&#39;, title: &#39;Item 2&#39; },
    { id: &#39;3&#39;, title: &#39;Item 3&#39; },
  ];

  const renderItem = ({ item }) =&gt; (
    &lt;View&gt;
      &lt;Text&gt;{item.title}&lt;/Text&gt;
    &lt;/View&gt;
  );

  return (
    &lt;FlatList
      data={data}
      renderItem={renderItem}
    /&gt;
  );
}
export default ListaItens;</code></pre>
<p>Listagem 2</p>
<pre><code>const renderItem = ({ item }) =&gt; (
  &lt;View style=&#123;&#123; backgroundColor: &#39;lightblue&#39;, marginVertical: 5, padding: 10, borderRadius: 5 }}&gt;
    &lt;Text&gt;{item.title}&lt;/Text&gt;
  &lt;/View&gt;
);</code></pre>
<p>Listagem 3</p>
<pre>const renderItem = ({ item }) =&gt; (
  &lt;Pressable onPress={() =&gt; Alert.alert(&#39;Item Pressionado&#39;, `ID: ${item.id}, Título: ${item.title}`)}&gt;
    &lt;View style=&#123;&#123; backgroundColor: &#39;lightblue&#39;, marginVertical: 5, padding: 10, borderRadius: 5 }}&gt;
      &lt;Text&gt;{item.title}&lt;/Text&gt;
    &lt;/View&gt;
  &lt;/Pressable&gt;
);</pre>
<p>Listagem 4</p>
<aside class="warning"><h3 is-upgraded><strong>Exercício 1: Renderizando uma lista simples</strong></h3>
<p>Crie um array de objetos, por exemplo:</p>
<p><strong>ver listagem 1 acima</strong></p>
<p>Crie um componente funcional chamado ListaItens que renderize um FlatList com os dados fornecidos. Utilize a propriedade <code>data</code> para passar o array de objetos e a propriedade <code>renderItem</code> para renderizar cada item da lista.</p>
<p><strong>ver Listagem 2 acima</strong></p>
<p>Renderize o componente ListaItens em seu aplicativo para visualizar a lista simples sendo exibida.</p>
<h3 is-upgraded><strong>Exercício 2: Personalizando o estilo dos itens da lista</strong></h3>
<p>Modifique o componente renderItem para personalizar o estilo dos itens da lista. Por exemplo, adicione uma cor de fundo, margens, bordas, etc.</p>
<p><strong>ver Listagem 3 acima</strong></p>
<p>Verifique a aparência atualizada dos itens da lista.</p>
<h3 is-upgraded><strong>Exercício 3: Lidando com eventos nos itens da lista</strong></h3>
<p>Modifique o componente renderItem para adicionar um evento de pressionar nos itens da lista. Por exemplo, exiba um alerta quando um item for pressionado.</p>
<p><strong>ver Listagem 4 acima</strong></p>
<p>Verifique se o alerta é exibido corretamente ao pressionar um item da lista.</p>
</aside>
<aside class="special"><p>A prática constante ajudará você a se familiarizar e aperfeiçoar suas habilidades com a FlatList no React Native.</p>
</aside>
<h2 is-upgraded><strong>Gerenciador de tarefas</strong></h2>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
