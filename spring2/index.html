
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Codelab - RESTful API com Spring Boot</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id=""
                  title="Codelab - RESTful API com Spring Boot"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Introdução" duration="5">
        <p class="image-container"><img style="width: 624.00px" src="img\\47e62796cee22f73.png"></p>
<h2 is-upgraded><strong>Definições</strong></h2>
<h3 is-upgraded><strong>REST</strong></h3>
<p>O termo <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">REST</a> é um acrônimo e significa <strong>Representational State Transfer</strong>. Rest é um paradigma arquitetônico usado no desenvolvimento de <em>web services</em>. Criado por Roy Fielding em 2000 em sua tese de <a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank">doutorado</a> defendida no ano de 2000 na Universidade da Califórnia, Irvine. </p>
<h3 is-upgraded><strong>RESTful API </strong></h3>
<p>Também conhecido como um web service RESTful. Web service construído em conformidade com o estilo de arquitetura REST e usa métodos HTTP.</p>
<h3 is-upgraded><strong>API</strong></h3>
<p>API é um conjunto de definições e protocolos usado no desenvolvimento e na integração de software de aplicações. API é um acrônimo em inglês que significa interface de programação de aplicações. As APIs costumam ser vistas como contratos, com documentações que representam um acordo entre as partes interessadas (<a href="https://www.redhat.com/pt-br/topics/api/what-are-application-programming-interfaces" target="_blank">referência</a>). Como exemplo podemos citar a API java (<a href="https://docs.oracle.com/en/java/javase/16/" target="_blank">referência</a>).</p>
<h3 is-upgraded><strong>Endpoint</strong></h3>
<p>Um endpoint de um web service é a URL onde seu serviço pode ser acessado por uma aplicação cliente (<a href="https://pt.stackoverflow.com/questions/86399/qual-a-diferen%C3%A7a-entre-endpoint-e-api" target="_blank">referência</a>).<img style="width: 296.00px" src="img\\6dea4a584f4d5054.png"></p>
<h3 is-upgraded><strong>Cliente web service</strong></h3>
<p class="image-container"><img style="width: 619.00px" src="img\\b050200838979391.png"></p>
<p>Aplicações que fornecem web services precisam de clientes que têm a capacidade de realizar requisições HTTP usando todos os tipos de métodos e, portanto, precisaremos de um cliente especial para testar nossas aplicações. Vamos usar uma aplicativo chamado Postman para consumir web services. </p>
<p><a href="https://documenter.getpostman.com/view/1277871/TzJsheff" target="_blank">Exemplo de uso de API usando Postman</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Métodos HTTP" duration="0">
        <p>Referências</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.3.16/reference/html/web.html#mvc-ann-requestmapping" target="_blank">Request Mapping</a></li>
<li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html" target="_blank">Class ResponseEntity&lt;T&gt;</a></li>
</ul>
<p class="image-container"><img style="width: 624.00px" src="img\\30bfa735c4166fa5.png"></p>
<h2 is-upgraded><strong>Idempotente </strong></h2>
<p>Um método HTTP é idempotente se uma requisição idêntica pode ser feita uma ou mais vezes em sequência com o mesmo efeito enquanto deixa o servidor no mesmo estado. Em outras palavras, um método idempotente não deveria possuir nenhum efeito colateral (exceto para manter estatísticas). Implementados corretamente, o GET, HEAD, PUT, e DELETE são métodos idempotentes, mas não o método POST. </p>
<h2 is-upgraded><strong>Códigos de status de resposta HTTP</strong></h2>
<p>Servem para informar ao cliente o status de suas requisições. O servidor retorna códigos de status genéricos. As categorias de código são:</p>
<ul>
<li>2xx - Sucesso - a requisição foi aceita com sucesso e executou a ação solicitada pelo cliente. </li>
<li>3xx - Redirecionamento - informa que o recurso solicitado não está mais disponível no local esperado. Isso pode ter vários motivos, sejam temporários ou permanentes, mas o cliente deve fazer uma requisição para o novo local.</li>
<li>4xx - Erro do cliente. O servidor não conseguiu entender a requisição, ou a requisição está incorreta. Existem várias causas para isso: timeout, URI errado, autenticação ausente, etc. </li>
<li>5xx - Erro do servidor.  O servidor falhou em atender a uma requisição devido à condição inesperada, armazenamento insuficiente, o código gera uma exceção.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Boas práticas para projetar RESTful API" duration="0">
        <p>Em REST, a representação de dados primária é chamada de recurso. Como boa prática de nomenclatura de recursos REST vamos seguir as seguintes diretivas.</p>
<ul>
<li>Não use verbos ou ações para descrever as APIs.</li>
<li>Use substantivos no plural ou no singular, mas deve ser consistente em todas as APIs.</li>
<li>O URL do endpoint deve conter métodos HTTP para descrever a funcionalidade da API. </li>
<li>Métodos HTTP </li>
</ul>
<table>
<tr><td colspan="1" rowspan="1"><p>POST</p>
</td><td colspan="1" rowspan="1"><p> Criar dados</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>GET</p>
</td><td colspan="1" rowspan="1"><p>Buscar dados</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>PUT</p>
</td><td colspan="1" rowspan="1"><p>Atualizar dados</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>DELETE</p>
</td><td colspan="1" rowspan="1"><p>Excluir dados</p>
</td></tr>
</table>
<h2 is-upgraded>Buscar dados</h2>
<p>Não faça assim </p>
<table>
<tr><td colspan="1" rowspan="1"><p><code>GET /buscaItem</code></p>
</td><td colspan="1" rowspan="1"><p>Para buscar todos os registros</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>GET /getTodosItens/12</code></p>
</td><td colspan="1" rowspan="1"><p>Para buscar registros específicos </p>
</td></tr>
</table>
<p>Faça assim </p>
<table>
<tr><td colspan="1" rowspan="1"><p><code>GET /itens</code></p>
</td><td colspan="1" rowspan="1"><p>Para buscar todos os registros</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>GET /itens/101</code></p>
</td><td colspan="1" rowspan="1"><p>Para buscar registros específicos </p>
</td></tr>
</table>
<h2 is-upgraded><strong>Criar dados</strong></h2>
<p>Não faça assim </p>
<table>
<tr><td colspan="1" rowspan="1"><p><code>POST /criaritem </code></p>
</td><td colspan="1" rowspan="1"><p>Para criar um novo registro</p>
</td></tr>
</table>
<p>Faça assim </p>
<table>
<tr><td colspan="1" rowspan="1"><p><code>POST /itens</code></p>
</td><td colspan="1" rowspan="1"><p>Para criar um novo registro</p>
</td></tr>
</table>
<h2 is-upgraded><strong>Atualizar dados</strong></h2>
<p>Não faça assim </p>
<table>
<tr><td colspan="1" rowspan="1"><p><code>PUT /atualizaritem/2</code></p>
</td><td colspan="1" rowspan="1"><p>Para atualizar um registro</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>POST /2/atualizaritem</code></p>
</td><td colspan="1" rowspan="1"><p>Para atualizar um registro</p>
</td></tr>
</table>
<p>Faça assim </p>
<table>
<tr><td colspan="1" rowspan="1"><p><code>PUT /itens/2</code></p>
</td><td colspan="1" rowspan="1"><p>Para atualizar um registro</p>
</td></tr>
</table>
<h2 is-upgraded><strong>Excluir dados</strong></h2>
<p>Não faça assim </p>
<table>
<tr><td colspan="1" rowspan="1"><p><code>DELETE /excluiritem/201</code></p>
</td><td colspan="1" rowspan="1"><p>Para excluir um registro</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>POST /201/removeitem</code></p>
</td><td colspan="1" rowspan="1"><p>Para excluir um registro</p>
</td></tr>
</table>
<p>Faça assim </p>
<table>
<tr><td colspan="1" rowspan="1"><p><code>DELETE /itens/201</code></p>
</td><td colspan="1" rowspan="1"><p>Para excluir um registro</p>
</td></tr>
</table>
<h2 is-upgraded><strong>Coleções de recursos </strong></h2>
<p>Podemos identificar o recurso de coleção &#34;clientes&#34; usando o URI &#34;<code>/clientes</code>&#34;. Podemos identificar um único recurso &#34;cliente&#34; usando o URI &#34;<code>/clientes/{id do cliente}</code>&#34;. </p>
<h2 is-upgraded><strong>Recursos de coleção e subcoleção </strong></h2>
<p>Um recurso também pode conter recursos de subcoleção. Por exemplo, o recurso de subcoleção &#34;contas&#34; de um &#34;cliente&#34; específico pode ser identificado usando o URI &#34;<code>/clientes/{id do cliente}/contas</code>&#34; (em um domínio bancário). Da mesma forma, um recurso singleton &#34;conta&#34; dentro do recurso de subcoleção &#34;contas&#34; pode ser identificado da seguinte forma: &#34;<code>/clientes/{id do cliente}/contas/{id da conta}</code>&#34;.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Construindo serviços REST com Spring" duration="0">
        <h2 is-upgraded><strong>Usando o modelo de camadas</strong></h2>
<p class="image-container"><img style="width: 624.00px" src="img\\71013e51f289c2d7.png"></p>
<h2 is-upgraded><strong>Criando o projeto Spring </strong></h2>
<ol type="1" start="1">
<li>Para criar novo projeto usando o VSCode, use o atalho <code>Ctrl + Shift + P</code> e digite spring init e escolha a opção mostrada abaixo:</li>
</ol>
<p class="image-container"><img style="width: 718.11px" src="img\\a168f98d6957a605.png"></p>
<ol type="1" start="2">
<li>Siga as escolhas mostradas abaixo:</li>
</ol>
<p class="image-container"><img style="width: 718.11px" src="img\\3e950d7f44248e8a.png"></p>
<p class="image-container"><img style="width: 718.11px" src="img\\f81a8ca797f9d8ba.png"></p>
<p class="image-container"><img style="width: 718.11px" src="img\\88a3bccefe7d3be.png"></p>
<p class="image-container"><img style="width: 718.11px" src="img\\5f9d7c439726be4a.png"></p>
<p class="image-container"><img style="width: 718.11px" src="img\\35aa7af700e332c8.png"></p>
<p class="image-container"><img style="width: 718.11px" src="img\\57f7e1bf20d3852e.png"></p>
<ol type="1" start="3">
<li>Escolher as dependências MySQL Driver, Spring Data JPA e Spring Web</li>
</ol>
<p class="image-container"><img style="width: 718.11px" src="img\\582bb57fe0f95fd6.png"></p>
<p class="image-container"><img style="width: 718.11px" src="img\\9a15682a3978f320.png"></p>
<p class="image-container"><img style="width: 718.11px" src="img\\f2d91d8b20637d07.png"></p>
<ol type="1" start="4">
<li>Pressione Enter para criar o projeto e escolha uma pasta no seu computador onde serão gravados os arquivos do projeto:</li>
</ol>
<p class="image-container"><img style="width: 718.11px" src="img\\28e066663d612608.png"></p>
<p class="image-container"><img style="width: 718.11px" src="img\\e9003e9b42266cb7.png"></p>
<ol type="1" start="5">
<li>No meu computador os projetos Spring ficam na pasta c:/Spring. Este projeto será gravado na pasta <code>C:\Spring\pessoa-api></code></li>
<li>Criar os pacotes ‘controller&#39;, ‘domain&#39;, ‘repository&#39;,  ‘service&#39;</li>
</ol>
<p class="image-container"><img style="width: 335.00px" src="img\\2be11bbebaee25d3.png"></p>
<ol type="1" start="7">
<li>Entidade Pessoa</li>
</ol>
<pre><code>package br.iftm.edu.pessoaapi.domain;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Pessoa {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String nome;

    public Pessoa() {
    }

    public Pessoa(String nome) {
        this.nome = nome;
    }

    public Integer getId() {
        return this.id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getNome() {
        return this.nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }
}</code></pre>
<ol type="1" start="8">
<li>Repositório para entidades do tipo Pessoa</li>
</ol>
<pre><code>package br.iftm.edu.pessoaapi.repository;

import java.util.List;
import org.springframework.data.repository.CrudRepository;
import br.iftm.edu.pessoaapi.domain.Pessoa;

public interface PessoaRepository extends CrudRepository&lt;Pessoa, Integer&gt; {
    @Override
    List&lt;Pessoa&gt; findAll();
}</code></pre>
<ol type="1" start="9">
<li>Service</li>
</ol>
<pre><code>package br.iftm.edu.pessoaapi.service;

import java.util.List;
import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.PathVariable;
import br.iftm.edu.pessoaapi.domain.Pessoa;
import br.iftm.edu.pessoaapi.repository.PessoaRepository;

@Service
public class PessoaService {

    @Autowired
    PessoaRepository repository;

    public List&lt;Pessoa&gt; todos() {
        return repository.findAll();
    }

    public Pessoa novo(Pessoa pessoa) {
        return repository.save(pessoa);
    }

    public Optional&lt;Pessoa&gt; busca(Integer id) {
        return repository.findById(id);
    }

    public Pessoa atualiza(Pessoa pessoa, Integer id) {
        pessoa.setId(id);
        return repository.save(pessoa);
    }

    public void exclui(@PathVariable Integer id) {
        repository.deleteById(id);
    }
}</code></pre>
<ol type="1" start="10">
<li>Controlador REST</li>
</ol>
<pre><code>package br.iftm.edu.pessoaapi.controller;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import br.iftm.edu.pessoaapi.domain.Pessoa;
import br.iftm.edu.pessoaapi.service.PessoaService;

@RestController
@RequestMapping(&#34;/pessoa&#34;)
class PessoaController {

    @Autowired
    private PessoaService service;

    @GetMapping
    public List&lt;Pessoa&gt; recuperaTodosRegistros() {
        return service.todos();
    }

    @PostMapping
    public Pessoa criaNovoRegistro(@RequestBody Pessoa pessoa) {
        return service.novo(pessoa);
    }

    @GetMapping(&#34;/{id}&#34;)
    public Pessoa buscaUmRegistro(@PathVariable Integer id) {
        return service.busca(id).orElseThrow(() -&gt; new PessoaNaoEncontradaException(id));
    }

    @PutMapping(&#34;/{id}&#34;)
    public Pessoa atualizaRegistro(@RequestBody Pessoa pessoa, @PathVariable Integer id) {
        return service.atualiza(pessoa, id);
    }

    @DeleteMapping(&#34;/{id}&#34;)
    void excluiRegistro(@PathVariable Integer id) {
        service.exclui(id);
    }
}</code></pre>
<ol type="1" start="11">
<li>Classe RuntimeException quando não encontrar uma pessoa no BD</li>
</ol>
<pre><code>package br.iftm.edu.pessoaapi.controller;

public class PessoaNaoEncontradaException extends RuntimeException {

    PessoaNaoEncontradaException(Integer id) {
        super(&#34;Não encontrei pessoa &#34; + id);
    }

}</code></pre>
<ol type="1" start="12">
<li>Classe @ControllerAdvice</li>
</ol>
<pre><code>package br.iftm.edu.pessoaapi.controller;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class PessoaNaoEncontradaAdvice {
    
    @ExceptionHandler
    ResponseEntity&lt;String&gt; employeeNotFoundHandler(PessoaNaoEncontradaException ex) {
        return new ResponseEntity&lt;String&gt;(ex.getMessage(), HttpStatus.NOT_FOUND);
    }
}</code></pre>
<ol type="1" start="13">
<li>Altere o arquivo /src/main/resources/application.properties: (Você precisa criar um esquema no seu SGBD MySQL chamado teste)</li>
</ol>
<pre><code>spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:3306/teste
spring.datasource.username=root
spring.datasource.password=

spring.jpa.show-sql=true
logging.level.org.springframework.web=trace</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Preparando o ambiente de testes" duration="0">
        <p>Postman é uma plataforma colaborativa para desenvolvimento de API. Vamos usar a funcionalidade de cliente API para realizar requisições HTTP e inspecionar a resposta. Clique na imagem abaixo para fazer o download e instalar o aplicativo e <strong>se cadastre para começar a usar a plataforma</strong>.</p>
<p><a href="https://www.postman.com/downloads/" target="_blank"><paper-button class="colored" raised>Download</paper-button></a></p>
<p>Depois de instalar o Postman, você deve copiar a coleção de requisições HTTP que usaremos para realizar os testes. Quando você clicar no botão <a href="https://app.getpostman.com/run-collection/1277871-76bcd60a-e0a7-4124-8624-aa68529e3bc6?action=collection%2Ffork&collection-url=entityId%3D1277871-76bcd60a-e0a7-4124-8624-aa68529e3bc6%26entityType%3Dcollection%26workspaceId%3De9a78e08-3c65-4fcf-94ef-fbd5870fd6c3" target="_blank"><paper-button class="colored" raised>Run in Postman</paper-button></a> vai aparecer a tela abaixo e você deverá escolher a opção ‘import a copy&#39; para copiar a coleção na sua instalação do Postman. Depois de escolher a opção para importar uma cópia da coleção, o browser pergunta se você permite a execução do Postman e você deverá clicar em ‘Abrir Postman&#39;</p>
<p class="image-container"><img style="width: 548.70px" src="img\\b1fdf71dd4e6b7a2.png"></p>
<p class="image-container"><img style="width: 544.00px" src="img\\aadf898388fe0ec2.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Testando a aplicação" duration="0">
        <p class="image-container"><img style="width: 718.11px" src="img\\8d57592871a4829a.png"></p>
<p>No lado esquerdo da tela temos a coleção <strong>RESTful API com Spring Boot</strong>, e quando você clica em cima do nome da coleção são mostradas as requisições abaixo:</p>
<p class="image-container"><img style="width: 293.00px" src="img\\a6e32811f58af826.png"></p>
<h2 is-upgraded><strong>POST</strong></h2>
<p>Vamos começar os testes usando o método POST. Para isso clique em ‘<strong>Cria uma nova pessoa no sistema</strong>&#39;, e do lado direito aparece: </p>
<p class="image-container"><img style="width: 718.11px" src="img\\4ccbe9debc87a3e8.png"></p>
<p>Para enviar os dados clique em Body / raw e escolha JSON na lista a direita (veja imagem abaixo) </p>
<p class="image-container"><img style="width: 362.00px" src="img\\21e8ffc93c82d06.png"></p>
<p>Na área abaixo, entre com um objeto Javascript com os dados a serem enviados (veja imagem abaixo)</p>
<p class="image-container"><img style="width: 718.11px" src="img\\ca3bb298c8865e1a.png"></p>
<p>Depois clique no botão Send e veja o retorno da requisição na parte de baixo da tela. Veja que agora o objeto exibe o valor para o campo id do objeto (<code>"id": 1</code>). Isto significa que o registro foi gravado no banco de dados.</p>
<h2 is-upgraded><strong>GET</strong></h2>
<h2 is-upgraded><img style="width: 718.11px" src="img\\ba0ec087caa24001.png"></h2>
<h2 is-upgraded><strong>PUT</strong></h2>
<h2 is-upgraded><img style="width: 718.11px" src="img\\628ad0e01e17581.png"></h2>
<p class="image-container"><img style="width: 718.11px" src="img\\b39b6aa05cd4ee61.png"></p>
<h2 is-upgraded><strong>DELETE</strong></h2>
<p class="image-container"><img style="width: 718.11px" src="img\\bca038a99f55ee7d.png"></p>
<p class="image-container"><img style="width: 718.11px" src="img\\aa6b3a21804a2e6.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Problemas com serialização com entidades relacionadas" duration="0">
        <p>O problema ocorre entre entidades que possuem relacionamento bidirecional e leva um loop infinito. Para evitar o problema devemos usar as anotações  </p>
<ul>
<li>@JsonManagedReference na classe que possui um atributo com a anotação @OneToMany</li>
<li>@JsonBackReference na classe que possui um atributo com a anotação @ManyToOne</li>
</ul>
<p>Exemplo:</p>
<pre><code>@Entity
@Data
public class TodoList {
        @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Integer id;
        private String nome;
        @OneToMany(mappedBy = &#34;lista&#34;)
        @JsonManagedReference
        private List&lt;TodoListItem&gt; itens = new ArrayList&lt;TodoListItem&gt;();        
}


@Entity
@Data
public class TodoListItem {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Integer id;
        private String nomeDoItem;
        @ManyToOne
        @JsonBackReference
        private TodoList lista;
}</code></pre>
<p class="image-container"><img style="width: 571.00px" src="img\\e136a6a10f488faf.png"></p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
